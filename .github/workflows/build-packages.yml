name: Build and Deploy Packages

on:
  push:
    branches: [ main ]
    paths:
      - 'pkgbuilds/**'
      - '.github/workflows/build-packages.yml'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Detect changed packages
      id: changed
      run: |
        # D√©tecter les PKGBUILD modifi√©s/ajout√©s/supprim√©s
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          # Mode manuel : build tous les paquets
          echo "packages_to_build=$(find pkgbuilds -name PKGBUILD -type f | sed 's|pkgbuilds/||;s|/PKGBUILD||' | tr '\n' ' ')" >> $GITHUB_OUTPUT
          echo "packages_to_remove=" >> $GITHUB_OUTPUT
        else
          # Mode automatique : d√©tecter les changements
          packages_to_build=""
          packages_to_remove=""
          
          # Obtenir le commit pr√©c√©dent (m√©thode robuste)
          before_commit=""
          if [ -n "${{ github.event.before }}" ] && [ "${{ github.event.before }}" != "0000000000000000000000000000000000000000" ]; then
            before_commit="${{ github.event.before }}"
          else
            # Essayer HEAD~1
            before_commit=$(git rev-parse HEAD~1 2>/dev/null || echo "")
          fi
          
          current_commit="${{ github.sha }}"
          
          if [ -n "$before_commit" ] && [ "$before_commit" != "$current_commit" ] && git cat-file -e "$before_commit" 2>/dev/null; then
            # R√©cup√©rer les fichiers modifi√©s/ajout√©s
            changed_files=$(git diff --name-only --diff-filter=ACMR "$before_commit" "$current_commit" 2>/dev/null | grep "^pkgbuilds/" || true)
            # R√©cup√©rer les fichiers supprim√©s
            deleted_files=$(git diff --name-only --diff-filter=D "$before_commit" "$current_commit" 2>/dev/null | grep "^pkgbuilds/" || true)
          else
            # Fallback : utiliser les fichiers modifi√©s dans le dernier commit
            changed_files=$(git diff-tree --no-commit-id --name-only --diff-filter=ACMR -r "$current_commit" 2>/dev/null | grep "^pkgbuilds/" || true)
            deleted_files=$(git diff-tree --no-commit-id --name-only --diff-filter=D -r "$current_commit" 2>/dev/null | grep "^pkgbuilds/" || true)
            
            # Si toujours rien, prendre tous les PKGBUILD pr√©sents (premi√®re ex√©cution)
            if [ -z "$changed_files" ] && [ -z "$deleted_files" ]; then
              changed_files=$(find pkgbuilds -name PKGBUILD -type f 2>/dev/null | sed 's|^|pkgbuilds/|' || true)
            fi
          fi
          
          # Paquets √† builder (ajout√©s ou modifi√©s)
          for file in $changed_files; do
            if [[ "$file" == */PKGBUILD ]]; then
              pkgname=$(echo "$file" | sed 's|pkgbuilds/||;s|/PKGBUILD||')
              # √âviter les doublons
              if ! echo "$packages_to_build" | grep -q "\b$pkgname\b"; then
                packages_to_build="$packages_to_build $pkgname"
              fi
            fi
          done
          
          # Paquets √† supprimer (PKGBUILD supprim√©)
          for file in $deleted_files; do
            if [[ "$file" == */PKGBUILD ]]; then
              pkgname=$(echo "$file" | sed 's|pkgbuilds/||;s|/PKGBUILD||')
              # √âviter les doublons
              if ! echo "$packages_to_remove" | grep -q "\b$pkgname\b"; then
                packages_to_remove="$packages_to_remove $pkgname"
              fi
            fi
          done
          
          # Nettoyer les espaces
          packages_to_build=$(echo "$packages_to_build" | xargs)
          packages_to_remove=$(echo "$packages_to_remove" | xargs)
          
          echo "packages_to_build=$packages_to_build" >> $GITHUB_OUTPUT
          echo "packages_to_remove=$packages_to_remove" >> $GITHUB_OUTPUT
        fi
        
        echo "üì¶ Packages to build: ${{ steps.changed.outputs.packages_to_build }}"
        echo "üóëÔ∏è Packages to remove: ${{ steps.changed.outputs.packages_to_remove }}"
    
    - name: Build packages using Arch Linux
      if: steps.changed.outputs.packages_to_build != ''
      run: |
        mkdir -p x86_64
        
        packages="${{ steps.changed.outputs.packages_to_build }}"
        
        for pkgname in $packages; do
          pkgdir="pkgbuilds/$pkgname"
          
          if [ ! -f "$pkgdir/PKGBUILD" ]; then
            echo "‚ö†Ô∏è PKGBUILD not found for $pkgname, skipping"
            continue
          fi
          
          echo "üî® Building package: $pkgname"
          
          # Build using Arch Linux container
          docker run --rm \
            -v "$(pwd)/$pkgdir:/build" \
            -v "$(pwd)/x86_64:/output" \
            -w /build \
            archlinux:latest \
            bash -c "
              set -e
              
              # Mettre √† jour le syst√®me et installer les outils de build
              pacman -Sy --noconfirm base-devel git sudo python python-pip
              
              # Cr√©er un utilisateur builder (makepkg ne peut pas tourner en root)
              useradd -m -s /bin/bash builder
              chown -R builder:builder /build /output
              
              # Configurer sudo pour builder (sans mot de passe)
              echo 'builder ALL=(ALL) NOPASSWD: ALL' > /etc/sudoers.d/builder
              chmod 0440 /etc/sudoers.d/builder
              
              # Builder le paquet en tant que builder
              # Note: makepkg -s installe automatiquement les d√©pendances via sudo pacman
              # Si certaines d√©pendances ne sont pas dans les d√©p√¥ts officiels,
              # on essaie d'abord avec -s, puis on r√©essaie avec --skipdeps si √ßa √©choue
              su builder -c 'cd /build && makepkg -s --noconfirm --cleanbuild' || {
                echo \"‚ö†Ô∏è Build avec d√©pendances automatiques a √©chou√©, tentative avec --skipdeps...\"
                # Installer les d√©pendances Python manquantes via pip (pour impacket, etc.)
                python -m pip install --break-system-packages impacket python-termcolor 2>/dev/null || true
                # R√©essayer sans installer les d√©pendances via pacman
                su builder -c 'cd /build && makepkg --noconfirm --skipdeps --cleanbuild' || {
                  echo \"‚ùå Failed to build $pkgname\"
                  echo \"V√©rifiez les d√©pendances dans le PKGBUILD\"
                  # Afficher les d√©pendances pour debug
                  if [ -f /build/PKGBUILD ]; then
                    echo \"D√©pendances du PKGBUILD:\"
                    grep -E '^(depends|makedepends|checkdepends)' /build/PKGBUILD || true
                  fi
                  exit 1
                }
              }
              
              # Copier les artefacts vers /output
              echo \"üì¶ Copying artifacts for $pkgname...\"
              cp -v /build/*.pkg.tar.zst /output/ 2>/dev/null || {
                echo \"‚ö†Ô∏è No .pkg.tar.zst found for $pkgname\"
                exit 1
              }
              
              echo \"‚úÖ Successfully built $pkgname\"
            " || {
            echo "‚ùå Failed to build $pkgname, continuing..."
            continue
          }
        done
        
        # S'assurer que les fichiers appartiennent au runner
        sudo chown -R $USER:$USER x86_64/ || true
    
    - name: Remove deleted packages
      if: steps.changed.outputs.packages_to_remove != ''
      run: |
        cd x86_64
        
        packages_to_remove="${{ steps.changed.outputs.packages_to_remove }}"
        
        for pkgname in $packages_to_remove; do
          echo "üóëÔ∏è Removing package: $pkgname"
          
          # Trouver et supprimer les fichiers de paquet correspondants
          find . -maxdepth 1 -name "${pkgname}-*.pkg.tar.*" -type f -delete || true
          
          # Si une base de donn√©es existe, utiliser repo-remove
          if [ -f "nihil.db.tar.xz" ] || [ -f "nihil.db.tar.gz" ]; then
            docker run --rm \
              -v "$(pwd):/repo" \
              -w /repo \
              archlinux:latest \
              bash -c "
                pacman -Sy --noconfirm pacman-contrib
                if [ -f nihil.db.tar.xz ]; then
                  repo-remove nihil.db.tar.xz '$pkgname' 2>/dev/null || true
                elif [ -f nihil.db.tar.gz ]; then
                  repo-remove nihil.db.tar.gz '$pkgname' 2>/dev/null || true
                fi
              " || true
          fi
        done
    
    - name: Update repository database
      run: |
        cd x86_64
        
        # V√©rifier qu'il y a des paquets
        if ! ls *.pkg.tar.zst 1> /dev/null 2>&1; then
          echo "‚ö†Ô∏è No packages found, skipping repository update"
          exit 0
        fi
        
        echo "üìù Updating repository database..."
        
        # Utiliser Arch Linux container pour repo-add
        docker run --rm \
          -v "$(pwd):/repo" \
          -w /repo \
          archlinux:latest \
          bash -c "
            set -e
            
            # Installer pacman-contrib pour repo-add
            pacman -Sy --noconfirm pacman-contrib
            
            # Supprimer les anciennes bases de donn√©es
            rm -f nihil.db nihil.db.tar.gz nihil.db.tar.xz
            rm -f nihil.files nihil.files.tar.gz nihil.files.tar.xz
            
            # G√©n√©rer la nouvelle base de donn√©es
            repo-add nihil.db.tar.xz *.pkg.tar.zst
            
            # Cr√©er les fichiers .db et .files non compress√©s
            # Les fichiers .db et .files sont des archives tar non compress√©es
            # qui contiennent les m√™mes fichiers que les .tar.xz
            TEMP_DIR=\$(mktemp -d)
            cd \$TEMP_DIR
            
            # Extraire nihil.db.tar.xz
            tar -xf /repo/nihil.db.tar.xz 2>/dev/null
            # Cr√©er nihil.db comme archive tar non compress√©e
            if [ -n \"\$(find . -type f)\" ]; then
              tar -cf /repo/nihil.db \$(find . -type f | sort) 2>/dev/null || true
            fi
            
            cd /
            rm -rf \$TEMP_DIR
            
            TEMP_DIR=\$(mktemp -d)
            cd \$TEMP_DIR
            
            # Extraire nihil.files.tar.xz
            tar -xf /repo/nihil.files.tar.xz 2>/dev/null
            # Cr√©er nihil.files comme archive tar non compress√©e
            if [ -n \"\$(find . -type f)\" ]; then
              tar -cf /repo/nihil.files \$(find . -type f | sort) 2>/dev/null || true
            fi
            
            cd /
            rm -rf \$TEMP_DIR
            
            echo \"‚úÖ Repository database updated\"
          "
        
        # V√©rifier que les fichiers ont √©t√© cr√©√©s
        ls -lh nihil.* || echo "‚ö†Ô∏è Warning: Some database files may be missing"
    
    - name: Commit and push changes
      run: |
        git config --local user.email "github-actions[bot]@users.noreply.github.com"
        git config --local user.name "github-actions[bot]"
        
        # Ajouter les nouveaux paquets et les bases de donn√©es
        git add x86_64/*.pkg.tar.zst x86_64/*.db* x86_64/*.files* 2>/dev/null || true
        
        # Supprimer les paquets supprim√©s
        git add -u x86_64/ || true
        
        # Commiter seulement s'il y a des changements
        if ! git diff --staged --quiet; then
          git commit -m "chore: update packages and repository database [skip ci]"
          git push
        else
          echo "No changes to commit"
        fi
